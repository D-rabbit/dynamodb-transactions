/**
 * Copyright 2014-2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/asl/
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express
 * or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
package com.amazonaws.services.dynamodbv2.transactions;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.PropertiesCredentials;
import com.amazonaws.services.dynamodbv2.AmazonDynamoDBClient;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIgnore;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBVersionAttribute;
import com.amazonaws.services.dynamodbv2.model.AttributeDefinition;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.ConditionalCheckFailedException;
import com.amazonaws.services.dynamodbv2.model.CreateTableRequest;
import com.amazonaws.services.dynamodbv2.model.DeleteItemRequest;
import com.amazonaws.services.dynamodbv2.model.DescribeTableRequest;
import com.amazonaws.services.dynamodbv2.model.GetItemRequest;
import com.amazonaws.services.dynamodbv2.model.GetItemResult;
import com.amazonaws.services.dynamodbv2.model.KeySchemaElement;
import com.amazonaws.services.dynamodbv2.model.KeyType;
import com.amazonaws.services.dynamodbv2.model.ProvisionedThroughput;
import com.amazonaws.services.dynamodbv2.model.PutItemRequest;
import com.amazonaws.services.dynamodbv2.model.ResourceInUseException;
import com.amazonaws.services.dynamodbv2.model.ReturnConsumedCapacity;
import com.amazonaws.services.dynamodbv2.model.ReturnValue;
import com.amazonaws.services.dynamodbv2.model.ScalarAttributeType;
import com.amazonaws.services.dynamodbv2.model.TableDescription;
import com.amazonaws.services.dynamodbv2.model.TableStatus;
import com.amazonaws.services.dynamodbv2.transactions.Transaction.AttributeName;
import com.amazonaws.services.dynamodbv2.transactions.Transaction.IsolationLevel;
import com.amazonaws.services.dynamodbv2.transactions.exceptions.DuplicateRequestException;
import com.amazonaws.services.dynamodbv2.transactions.exceptions.TransactionNotFoundException;
import com.amazonaws.services.dynamodbv2.transactions.exceptions.TransactionRolledBackException;
import com.amazonaws.services.dynamodbv2.util.ImmutableKey;

public class MapperTransactionsIntegrationTest {

    private static final String ID_ATTRIBUTE = "Id";
    protected static final AmazonDynamoDBClient dynamodb;
    private static final String HASH_TABLE_NAME = "TransactionsIntegrationTest_Hash";
    private static final String HASH_RANGE_TABLE_NAME = "TransactionsIntegrationTest_HashRange";
    private static final String LOCK_TABLE_NAME = "TransactionsIntegrationTest_Transactions";
    private static final String IMAGES_TABLE_NAME = "TransactionsIntegrationTest_ItemImages";
    private static final String TABLE_NAME_PREFIX = new SimpleDateFormat("yyyy-MM-dd'T'HH-mm-ss").format(new Date());
    private static final String DYNAMODB_ENDPOINT = "http://dynamodb.us-west-2.amazonaws.com";

    @DynamoDBTable(tableName = HASH_TABLE_NAME)
    public static class ExampleHashKeyItem {
        private String id;
        private String something;
        private Set<String> someSet;

        @DynamoDBHashKey(attributeName = ID_ATTRIBUTE)
        @DynamoDBAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDBAttribute
        public String getSomething() {
            return something;
        }

        public void setSomething(String something) {
            this.something = something;
        }

        @DynamoDBAttribute
        public Set<String> getSomeSet() {
            return someSet;
        }

        public void setSomeSet(Set<String> someSet) {
            this.someSet = someSet;
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getKey() {
            return Collections.singletonMap(ID_ATTRIBUTE, new AttributeValue().withS(getId()));
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getExpectedValues() {
            Map<String, AttributeValue> expected = new HashMap<String, AttributeValue>();
            expected.put("something", new AttributeValue().withS(getSomething()));
            if (getSomeSet() != null) {
                // we need to sort the values, because AttributeValue internally
                // copies our set to an ordered list
                ArrayList<String> valuesList = new ArrayList<String>(getSomeSet());
                Collections.sort(valuesList);
                expected.put("someSet", new AttributeValue().withSS(valuesList));
            }
            expected.putAll(getKey());
            return expected;
        }

    }

    private ExampleHashKeyItem hashItem0;

    private Map<String, AttributeValue> key0;
    private Map<String, AttributeValue> item0;

    private final TransactionManager manager;

    protected static String getLockTableName() {
        return  TABLE_NAME_PREFIX + "_" + LOCK_TABLE_NAME;
    }

    protected static String getImagesTableName() {
        return TABLE_NAME_PREFIX + "_" + IMAGES_TABLE_NAME;
    }

    protected static String getHashTableName() {
        return TABLE_NAME_PREFIX + "_" + HASH_TABLE_NAME;
    }

    protected static String getHashRangeTableName() {
        return TABLE_NAME_PREFIX + "_" + HASH_RANGE_TABLE_NAME;
    }

    protected Map<String, AttributeValue> newKey(String tableName) {
        Map<String, AttributeValue> key = new HashMap<String, AttributeValue>();
        key.put(ID_ATTRIBUTE, new AttributeValue().withS("val_" + Math.random()));
        if(getHashTableName().equals(tableName)) {
            // no-op
        } else if (getHashRangeTableName().equals(tableName)) {
            key.put("RangeAttr", new AttributeValue().withN(new Double(Math.random()).toString()));
        } else {
            throw new IllegalArgumentException();
        }
        return key;
    }

    private ExampleHashKeyItem newItem() {
        ExampleHashKeyItem item1 = new ExampleHashKeyItem();
        item1.setId(UUID.randomUUID().toString());
        return item1;
    }

    @BeforeClass
    public static void createTables() throws InterruptedException {
        try {
            CreateTableRequest createHash = new CreateTableRequest()
                .withTableName(getHashTableName())
                .withAttributeDefinitions(new AttributeDefinition().withAttributeName(ID_ATTRIBUTE).withAttributeType(ScalarAttributeType.S))
                .withKeySchema(new KeySchemaElement().withAttributeName(ID_ATTRIBUTE).withKeyType(KeyType.HASH))
                .withProvisionedThroughput(new ProvisionedThroughput().withReadCapacityUnits(5L).withWriteCapacityUnits(5L));
            dynamodb.createTable(createHash);
        } catch (ResourceInUseException e) {
            System.err.println("Warning: " + getHashTableName() + " was already in use");
        }

        try {
            TransactionManager.verifyOrCreateTransactionTable(dynamodb, getLockTableName(), 10L, 10L, 5L * 60);
            TransactionManager.verifyOrCreateTransactionImagesTable(dynamodb, getImagesTableName(), 10L, 10L, 5L * 60);
        } catch (ResourceInUseException e) {
            System.err.println("Warning: " + getHashTableName() + " was already in use");
        }

        waitForTableToBecomeAvailable(getHashTableName());
        waitForTableToBecomeAvailable(getLockTableName());
        waitForTableToBecomeAvailable(getImagesTableName());
    }

    @Before
    public void setup() {
        Transaction t = manager.newTransaction();
        hashItem0 = new ExampleHashKeyItem();
        hashItem0.setId(UUID.randomUUID().toString());
        hashItem0.setSomething("val");
        hashItem0.setSomeSet(new HashSet<String>(Arrays.asList("one", "two")));
        t.save(hashItem0);
        key0 = newKey(getHashTableName());
        item0 = new HashMap<String, AttributeValue>(key0);
        item0.put("s_someattr", new AttributeValue("val"));
        item0.put("ss_otherattr", new AttributeValue().withSS("one", "two"));
        Map<String, AttributeValue> putResult = t.putItem(new PutItemRequest()
            .withTableName(getHashTableName())
            .withItem(item0)
            .withReturnValues(ReturnValue.ALL_OLD)).getAttributes();
        assertNull(putResult);
        t.commit();
        assertItemNotLocked(getHashTableName(), key0, item0, true);
        assertItemNotLocked(getHashTableName(), hashItem0.getKey(), hashItem0.getExpectedValues(), true);
    }

    @After
    public void teardown() {
        Transaction t = manager.newTransaction();
        t.deleteItem(new DeleteItemRequest().withTableName(getHashTableName()).withKey(key0));
        t.commit();
        assertItemNotLocked(getHashTableName(), key0, false);
    }

    private static void waitForTableToBecomeAvailable(String tableName) {
        System.out.println("Waiting for " + tableName + " to become ACTIVE...");

        long startTime = System.currentTimeMillis();
        long endTime = startTime + (10 * 60 * 1000);
        while (System.currentTimeMillis() < endTime) {
            DescribeTableRequest request = new DescribeTableRequest()
                    .withTableName(tableName);
            TableDescription tableDescription = dynamodb.describeTable(
                    request).getTable();
            String tableStatus = tableDescription.getTableStatus();
            System.out.println("  - current state: " + tableStatus);
            if (tableStatus.equals(TableStatus.ACTIVE.toString()))
                return;
            try { Thread.sleep(1000 * 10); } catch (Exception e) { }
        }
        throw new RuntimeException("Table " + tableName + " never went active");
    }

    static {
        AWSCredentials credentials;
        try {
            credentials = new PropertiesCredentials(
                    TransactionsIntegrationTest.class.getResourceAsStream("AwsCredentials.properties"));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        dynamodb = new AmazonDynamoDBClient(credentials);
        dynamodb.setEndpoint(DYNAMODB_ENDPOINT);
    }

    public MapperTransactionsIntegrationTest() throws IOException {
        manager = new TransactionManager(
                dynamodb, getLockTableName(), getImagesTableName(),
                new DynamoDBMapperConfig(
                        DynamoDBMapperConfig.TableNameOverride.withTableNamePrefix(TABLE_NAME_PREFIX + "_")));
    }

    @Test
    public void phantomItemFromDelete() {
        ExampleHashKeyItem item1 = newItem();
        Transaction transaction = manager.newTransaction();
        transaction.delete(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), transaction.getId(), true, false);
        transaction.rollback();
        assertItemNotLocked(getHashTableName(), item1.getKey(), false);
        transaction.delete(Long.MAX_VALUE);
    }

    /*
     * GetItem tests
     */

    @Test
    public void lockItem() {
        ExampleHashKeyItem item1 = newItem();

        Transaction t1 = manager.newTransaction();
        Transaction t2 = manager.newTransaction();

        ExampleHashKeyItem loadedItem = t1.load(item1);

        assertItemLocked(getHashTableName(), item1.getKey(), t1.getId(), true, false); // we're not applying locks
        assertNull(loadedItem);

        t2.delete(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), t2.getId(), true, false); // we're not applying deletes either

        t2.commit();

        try {
            t1.commit();
            fail();
        } catch (TransactionRolledBackException e) { }

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);

        assertItemNotLocked(getHashTableName(), item1.getKey(), false);
    }

    @Test
    public void lock2Items() {
        ExampleHashKeyItem item1 = newItem();
        ExampleHashKeyItem item2 = newItem();

        Transaction t0 = manager.newTransaction();
        item1.setSomething("val");
        t0.save(item1);

        t0.commit();

        Transaction t1 = manager.newTransaction();

        ExampleHashKeyItem loadedItem1 = t1.load(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), t1.getId(), false, false);
        assertEquals(item1.getExpectedValues(), loadedItem1.getExpectedValues());

        ExampleHashKeyItem loadedItem2 = t1.load(item2);
        assertItemLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), t1.getId(), false, false);
        assertItemLocked(getHashTableName(), item2.getKey(), t1.getId(), true, false);
        assertNull(loadedItem2);

        t1.commit();
        t1.delete(Long.MAX_VALUE);

        assertItemNotLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), true);
        assertItemNotLocked(getHashTableName(), item2.getKey(), false);
    }

    @Test
    public void getItemWithDelete() {
        Transaction t1 = manager.newTransaction();
        ExampleHashKeyItem loadedItem1 = t1.load(hashItem0);
        assertEquals(hashItem0.getExpectedValues(), loadedItem1.getExpectedValues());
        assertItemLocked(getHashTableName(), hashItem0.getKey(), loadedItem1.getExpectedValues(), t1.getId(), false, false);

        t1.delete(hashItem0);
        assertItemLocked(getHashTableName(), hashItem0.getKey(), hashItem0.getExpectedValues(), t1.getId(), false, false);

        ExampleHashKeyItem loadedItem2 = t1.load(hashItem0);
        assertNull(loadedItem2);
        assertItemLocked(getHashTableName(), hashItem0.getKey(), hashItem0.getExpectedValues(), t1.getId(), false, false);

        t1.commit();
        assertItemNotLocked(getHashTableName(), hashItem0.getKey(), false);
    }

    @Test
    public void getItemNotExists() {
        Transaction t1 = manager.newTransaction();
        ExampleHashKeyItem item1 = newItem();

        ExampleHashKeyItem loadedItem1 = t1.load(item1);
        assertNull(loadedItem1);
        assertItemLocked(getHashTableName(), item1.getKey(), t1.getId(), true, false);

        ExampleHashKeyItem loadedItem2 = t1.load(item1);
        assertNull(loadedItem2);
        assertItemLocked(getHashTableName(), item1.getKey(), t1.getId(), true, false);

        t1.commit();

        assertItemNotLocked(getHashTableName(), item1.getKey(), false);
    }

    @Test
    public void getItemAfterPutItemInsert() {
        Transaction t1 = manager.newTransaction();
        ExampleHashKeyItem item1 = newItem();
        item1.setSomething("wef");

        ExampleHashKeyItem loadedItem1 = t1.load(item1);
        assertNull(loadedItem1);
        assertItemLocked(getHashTableName(), item1.getKey(), t1.getId(), true, false);

        t1.save(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), t1.getId(), true, true);

        ExampleHashKeyItem loadedItem2 = t1.load(item1);
        assertEquals(item1.getExpectedValues(), loadedItem2.getExpectedValues());
        assertItemLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), t1.getId(), true, true);

        t1.commit();

        assertItemNotLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), true);
    }

    /*
     * Transaction isolation and error tests
     */

    @Test
    public void conflictingWrites() {
        ExampleHashKeyItem item1 = newItem();
        Transaction t1 = manager.newTransaction();
        Transaction t2 = manager.newTransaction();
        Transaction t3 = manager.newTransaction();

        // Finish t1
        ExampleHashKeyItem t1Item = new ExampleHashKeyItem();
        t1Item.setId(item1.getId());
        t1Item.setSomething("t1");

        t1.save(t1Item);
        assertItemLocked(getHashTableName(), item1.getKey(), t1Item.getExpectedValues(), t1.getId(), true, true);

        t1.commit();
        assertItemNotLocked(getHashTableName(), item1.getKey(), t1Item.getExpectedValues(), true);

        // Begin t2
        ExampleHashKeyItem t2Item = new ExampleHashKeyItem();
        t2Item.setId(item1.getId());
        t2Item.setSomething("t2");
        t2Item.setSomeSet(Collections.singleton("extra"));

        t2.save(t2Item);
        assertItemLocked(getHashTableName(), item1.getKey(), t2Item.getExpectedValues(), t2.getId(), false, true);

        // Begin and finish t3
        ExampleHashKeyItem t3Item = new ExampleHashKeyItem();
        t3Item.setId(item1.getId());
        t3Item.setSomething("t3");
        t3Item.setSomeSet(Collections.singleton("things"));

        t3.save(t3Item);
        assertItemLocked(getHashTableName(), item1.getKey(), t3Item.getExpectedValues(), t3.getId(), false, true);

        t3.commit();

        assertItemNotLocked(getHashTableName(), item1.getKey(), t3Item.getExpectedValues(), true);

        // Ensure t2 rolled back
        try {
            t2.commit();
            fail();
        } catch (TransactionRolledBackException e) { }

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);

        assertItemNotLocked(getHashTableName(), item1.getKey(), t3Item.getExpectedValues(), true);
    }

    @DynamoDBTable(tableName = HASH_TABLE_NAME)
    public static class ExampleVersionedHashKeyItem {
        private String id;
        private Long version = null;

        @DynamoDBHashKey(attributeName = ID_ATTRIBUTE)
        @DynamoDBAutoGeneratedKey
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @DynamoDBVersionAttribute
        public Long getVersion() {
            return version;
        }

        public void setVersion(Long version) {
            this.version = version;
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getKey() {
            return Collections.singletonMap(ID_ATTRIBUTE, new AttributeValue().withS(getId()));
        }

        @DynamoDBIgnore
        public Map<String, AttributeValue> getExpectedValues() {
            Map<String, AttributeValue> expected = new HashMap<String, AttributeValue>();
            expected.put("version", new AttributeValue().withN(getVersion().toString()));
            expected.putAll(getKey());
            return expected;
        }

    }

    @Test
    public void createVersionedItemWhenItemAlreadyExists() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();
        assertItemNotLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), true);

        ExampleVersionedHashKeyItem item2 = new ExampleVersionedHashKeyItem();
        item2.setId(item1.getId());
        Transaction t2 = manager.newTransaction();
        try {
            t2.save(item2);
            fail();
        } catch (ConditionalCheckFailedException e) {
            t2.rollback();
        }
        assertItemNotLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
    }

    @Test
    public void createVersionedItemInConflictingTransactions() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), t1.getId(), true, true);

        // while the item is being created in the first transaction, create it in another transaction
        ExampleVersionedHashKeyItem item2 = new ExampleVersionedHashKeyItem();
        item2.setId(item1.getId());
        Transaction t2 = manager.newTransaction();
        t2.save(item2);
        t2.commit();

        // try to commit the original transaction
        try {
            t1.commit();
            fail();
        } catch (TransactionRolledBackException e) { }
        assertItemNotLocked(getHashTableName(), item1.getKey(), item1.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
    }

    @Test
    public void deleteVersionedItemWithOutOfDateVersion() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();

        // update the item to version 2
        Transaction t2 = manager.newTransaction();
        ExampleVersionedHashKeyItem item2 = t2.load(item1);
        t2.save(item2);
        t2.commit();

        // try to delete with an outdated view of the item
        Transaction t3 = manager.newTransaction();
        try {
            t3.delete(item1);
            fail();
        } catch (ConditionalCheckFailedException e) {
            t3.rollback();
        }
        assertItemNotLocked(getHashTableName(), item2.getKey(), item2.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);
    }

    @Test
    public void reusingMapperInstanceWithOutOfDateVersionThrowsOnSave() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();

        // update the item to version 2 and save
        Transaction t2 = manager.newTransaction();
        ExampleVersionedHashKeyItem item2 = t2.load(item1);
        t2.save(item2);
        t2.commit();

        Transaction t3 = manager.newTransaction();
        t3.load(item1);
        try {
            t3.save(item1);
            fail();
        } catch (ConditionalCheckFailedException e) {
            t3.rollback();
        }
        assertItemNotLocked(getHashTableName(), item2.getKey(), item2.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);
    }

    @Test
    public void deleteVersionedItemInConflictingTransaction() {
        ExampleVersionedHashKeyItem item1 = newVersionedItem();

        // establish the item with version 1
        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        t1.commit();

        // start to delete the item
        Transaction t2 = manager.newTransaction();
        t2.delete(item1);

        // update the item to version 2
        Transaction t3 = manager.newTransaction();
        ExampleVersionedHashKeyItem item2 = t3.load(item1);
        t3.save(item2);
        t3.commit();

        // try to commit the delete
        try {
            t2.commit();
            fail();
        } catch (TransactionRolledBackException e) { }

        assertItemNotLocked(getHashTableName(), item2.getKey(), item2.getExpectedValues(), true);

        t1.delete(Long.MAX_VALUE);
        t2.delete(Long.MAX_VALUE);
        t3.delete(Long.MAX_VALUE);
    }

    private ExampleVersionedHashKeyItem newVersionedItem() {
        ExampleVersionedHashKeyItem item1 = new ExampleVersionedHashKeyItem();
        item1.setId(UUID.randomUUID().toString());
        return item1;
    }

    @Test
    public void readCommitted() {
        ExampleHashKeyItem item1 = newItem();
        item1.setSomething("example");

        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), t1.getId(), true, true);

        ExampleHashKeyItem loadedItem1 = manager.load(item1, IsolationLevel.COMMITTED);
        assertNull(loadedItem1);

        t1.commit();
        assertItemNotLocked(getHashTableName(), item1.getKey(), true);

        ExampleHashKeyItem loadedItem2 = manager.load(item1, IsolationLevel.COMMITTED);
        assertNotNull(loadedItem2);
        assertEquals(item1.getExpectedValues(), loadedItem2.getExpectedValues());

        t1.delete(Long.MAX_VALUE);
    }

    @Test
    public void readUncommitted() {
        ExampleHashKeyItem item1 = newItem();
        item1.setSomething("example");

        Transaction t1 = manager.newTransaction();
        t1.save(item1);
        assertItemLocked(getHashTableName(), item1.getKey(), t1.getId(), true, true);

        ExampleHashKeyItem loadedItem1 = manager.load(item1, IsolationLevel.UNCOMMITTED);
        assertNotNull(loadedItem1);
        assertEquals(item1.getExpectedValues(), loadedItem1.getExpectedValues());

        t1.rollback();
        assertItemNotLocked(getHashTableName(), item1.getKey(), false);

        ExampleHashKeyItem loadedItem2 = manager.load(item1, IsolationLevel.COMMITTED);
        assertNull(loadedItem2);

        t1.delete(Long.MAX_VALUE);
    }

    private void assertItemLocked(String tableName, Map<String, AttributeValue> key, Map<String, AttributeValue> expected, String owner, boolean isTransient, boolean isApplied) {
        assertItemLocked(tableName, key, expected, owner, isTransient, isApplied, true);
    }

    private void assertItemLocked(String tableName, Map<String, AttributeValue> key, Map<String, AttributeValue> expected, String owner, boolean isTransient, boolean isApplied, boolean checkTxItem) {
        Map<String, AttributeValue> item = getItem(tableName, key);
        assertNotNull(item);
        assertEquals(owner, item.get(AttributeName.TXID.toString()).getS());
        if(isTransient) {
            assertTrue("item is not transient, and should have been", item.containsKey(AttributeName.TRANSIENT.toString()));
            assertEquals("item is not transient, and should have been", "1", item.get(AttributeName.TRANSIENT.toString()).getS());
        } else {
            assertNull("item is transient, and should not have been", item.get(AttributeName.TRANSIENT.toString()));
        }
        if(isApplied) {
            assertTrue("item is not applied, and should have been", item.containsKey(AttributeName.APPLIED.toString()));
            assertEquals("item is not applied, and should have been", "1", item.get(AttributeName.APPLIED.toString()).getS());
        } else {
            assertNull("item is applied, and should not have been", item.get(AttributeName.APPLIED.toString()));
        }
        assertTrue(item.containsKey(AttributeName.DATE.toString()));
        if(expected != null) {
            item.remove(AttributeName.TXID.toString());
            item.remove(AttributeName.TRANSIENT.toString());
            item.remove(AttributeName.APPLIED.toString());
            item.remove(AttributeName.DATE.toString());
            assertEquals(expected, item);
        }
        // Also verify that it is locked in the tx record
        if(checkTxItem) {
            TransactionItem txItem = new TransactionItem(owner, manager, false);
            assertTrue(txItem.getRequestMap().containsKey(tableName));
            assertTrue(txItem.getRequestMap().get(tableName).containsKey(new ImmutableKey(key)));
        }
    }

    private void assertItemLocked(String tableName, Map<String, AttributeValue> key, String owner, boolean isTransient, boolean isApplied) {
        assertItemLocked(tableName, key, null, owner, isTransient, isApplied);
    }

    private void assertItemNotLocked(String tableName, Map<String, AttributeValue> key, Map<String, AttributeValue> expected, boolean shouldExist) {
        Map<String, AttributeValue> item = getItem(tableName, key);
        if(shouldExist) {
            assertNotNull("Item does not exist in the table, but it should", item);
            assertNull(item.get(AttributeName.TRANSIENT.toString()));
            assertNull(item.get(AttributeName.TXID.toString()));
            assertNull(item.get(AttributeName.APPLIED.toString()));
            assertNull(item.get(AttributeName.DATE.toString()));
        } else {
            assertNull("Item should have been null: " + item, item);
        }

        if(expected != null) {
            item.remove(AttributeName.TXID.toString());
            item.remove(AttributeName.TRANSIENT.toString());
            assertEquals(expected, item);
        }
    }

    private void assertItemNotLocked(String tableName, Map<String, AttributeValue> key, boolean shouldExist) {
        assertItemNotLocked(tableName, key, null, shouldExist);
    }

    protected void assertTransactionDeleted(Transaction t) {
        try {
            manager.resumeTransaction(t.getId());
            fail();
        } catch (TransactionNotFoundException e) { }
    }

    protected void assertNoSpecialAttributes(Map<String, AttributeValue> item) {
        for(String attrName : Transaction.SPECIAL_ATTR_NAMES) {
            if(item.containsKey(attrName)) {
                fail("Should not have contained attribute " + attrName + " " + item);
            }
        }
    }

    protected void assertOldItemImage(String txId, String tableName, Map<String, AttributeValue> key, Map<String, AttributeValue> item, boolean shouldExist) {
        Transaction t = manager.resumeTransaction(txId);
        Map<String, HashMap<ImmutableKey, Request>> requests = t.getTxItem().getRequestMap();
        Request r = requests.get(tableName).get(new ImmutableKey(key));
        Map<String, AttributeValue> image = t.getTxItem().loadItemImage(r.getRid());
        if(shouldExist) {
            assertNotNull(image);
            image.remove(AttributeName.TXID.toString());
            image.remove(AttributeName.IMAGE_ID.toString());
            image.remove(AttributeName.DATE.toString());
            assertTrue(! image.containsKey(AttributeName.TRANSIENT.toString()));
            assertEquals(item, image);
        } else {
            assertNull(image);
        }
    }

    private Map<String, AttributeValue> getItem(String tableName, Map<String, AttributeValue> key) {
        GetItemResult result = dynamodb.getItem(new GetItemRequest()
            .withTableName(tableName)
            .withKey(key)
            .withReturnConsumedCapacity(ReturnConsumedCapacity.TOTAL)
            .withConsistentRead(true));
        return result.getItem();
    }

    @Test
    public void oneTransactionPerItem() {
        Transaction transaction = manager.newTransaction();
        Map<String, AttributeValue> key = newKey(getHashTableName());

        transaction.putItem(new PutItemRequest()
            .withTableName(getHashTableName())
            .withItem(key));
        try {
            transaction.putItem(new PutItemRequest()
                .withTableName(getHashTableName())
                .withItem(key));
            fail();
        } catch(DuplicateRequestException e) {
            transaction.rollback();
        }
        assertItemNotLocked(getHashTableName(), key, false);
        transaction.delete(Long.MAX_VALUE);
    }

}
